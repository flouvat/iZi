/*
 *  Copyright (C) 2006 Frédéric Flouvat
 *  Written by Frédéric Flouvat
 *  Updated by Frédéric Flouvat
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */
 
#ifndef APRIORI_HXX
#define APRIORI_HXX

#include "NoOutput.hxx"
#include "Id.hpp"
#include "TransformElement.hxx"
#include "Complement.hxx"
#include "Boolean.hpp"
#include "PTree.hxx"
 
 #include <deque>

//! Functor finding the theory and/or the negative border and/or the positive border using the algorithm Apriori.
/**
    This class enables the execution of the classic Apriori algorithm.
    Moreover this class enables to stop the execution of Apriori at an iteration wrt to a user defined functor.
    The template parameter SetsType represents the type of the sets representing the elements of the language.
    The template parameter Measure is the type of the value eventually associated with the word of the language.
    The template parameter Cand_DataStruct is the data structure type used to store the candidates generated by the algorithms.
*/
template< class SetsType=int, class Measure=Boolean, class Cand_DataStruct = PTree<SetsType,Measure> >
class Apriori
{
        //! Class used  when there is no stopIteration functor in Apriori
        class NoStopIteration
        {
            public:
                int level;
                   
                void update(  Cand_DataStruct & candidates ) {}       
                bool operator() ( Cand_DataStruct & candidates ) {return false;}                   
        };
                   
      protected:
                
        //! Initialize the set of candidates with the basic words of the language
        template< class f >
        class initCandidates
        {
                // set of candidates                          
                Cand_DataStruct * cand;
                
                // function transforming words in sets
                f * wordToSet;
                
                // when the problems studied is composed of itemset (transformation function = id)
                // the user can directly insert in the init function the items in listElements
                // but in the candidate data structure only sets of items can be inserted 
                // so we must use in this case a temporary container to have the right type
                template< class Word >
                void insItems( Cand_DataStruct * cand, Word & w, Id * id)
                { 
                    vector<Word> buffer(1) ;
                    buffer[0] = w;
        
                    cand->push_back(  buffer  ) ; // insert in candidates the set 
                }  
                
                template< class Word >
                void insItems( Cand_DataStruct * cand, Word & w, Complement<SetsType> * complem)
                { 
                    vector<Word> buffer(1) ;
                    buffer[0] = w;          
                    
                    // initialize the set of all the elements to complement
                    if( ! complem->listElements )
                        complem->listElements = new vector<Word> ;
                    
                    complem->listElements->push_back( w ) ;
                            
        
                    cand->push_back(  buffer  ) ; // insert in candidates the set
                }  

                template< class Word, class WordToSet >
                void insItems( Cand_DataStruct * cand, Word & w, TransformElement< Complement<SetsType> ,SetsType, WordToSet , Word>  * wordToSetComplem)
                { 
                    vector<SetsType> * set  = (* wordToSetComplem->wordtoset )( & w );          
 
                    cand->push_back(  * set  ) ; // insert in candidates the set of size 1
                                    
                    
                    // initialize the set of all the elements to complement
                    if( ! wordToSetComplem->transformset->listElements )
                        wordToSetComplem->transformset->listElements = new vector<SetsType> ;
                    
                    wordToSetComplem->transformset->listElements->push_back( set->at(0)  ) ;                                   

                }  
                                
                     
                template< class Word, class f2  >
                void insItems( Cand_DataStruct * cand , Word & w, f2 * inwordToSet)
                {  
                     cand->push_back( * (*inwordToSet)( &w )  ) ; // insert in candidates the set representaion of the word 
                }           
                                                                         
            public:
                initCandidates( Cand_DataStruct & incandidates, f& inwordToSet  ){ cand = & incandidates ; wordToSet = &inwordToSet;  }
                
                template< class Word >
                void operator() (Word & w)
                { 
                     insItems( cand, w, wordToSet);
                }                         
        };       
        
       
                            
        //! Test if a set generated using the elements pointed by itPref and itLast is a candidate.
        /**      
           \param itPref iterator on the prefix of the set to test. 
           \param itLast iterator on the elemnt to add to form the candidate set.    
           \param buffer container of size k used to test subset.    
           \return true if all the subsets of size k are already in the candidate.
        */
        template< class Iterator >
        bool testSubset( Iterator & itPref, Iterator & itLast, vector<SetsType> & buffer ) ;
        
        //! Erase all the k-1 subsets of the set of size k coresponding to the iterator in parameter.
        /**   
           \param cand contains the theory.
           \param position iterator on the set. 
           \param buffer container of size k used to test subset.    
        */
        template< class Iterator >
        void eraseSubset( Cand_DataStruct & cand, Iterator & position,  vector<SetsType> & buffer ) ;
                               
        //! Filter the elements of the positive border from the theory
        /**
           \param cand contains the theory. 
        */
        void filter( Cand_DataStruct & cand ) ;
      
    public:
        
        //! Boolean to print to screen some informations during the execution (default false)
        bool verbose; 
        
        //! Boolean to save the set representation of the solution
        bool saveSet;
            
    protected:
        
        //! The candidates generated.        
        Cand_DataStruct candidates ;
               

    protected:

        //! Candidate generation phase of Apriori. 
        /**
           \param cand set of candidates.
           \param level current size of the candidates
           \return the number of sets generated.
        */     
        int candidatesGeneration( Cand_DataStruct & cand , int &level);      
        
        //! Pruning generation phase of Apriori.
        /**
           \param cand set of candidates.
           \param pred the predicate.
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).                      
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).                      
           \param setToWordSave  transform for output the sets find by the algorithm in words of the language.               
           \param listInterestItems list of all the interesting items (set representation).             
           \return the number of candidates pruned.
        */
        template<class Predicate, class OutputTheory , class OutputBdN, class f, class f2 >
        int prune(  Cand_DataStruct & cand,  Predicate * pred,  OutputTheory * theory  , OutputBdN * bdN , f & wordToSet, f2 & wordToSetSave, deque<SetsType> * listInteresItems =0 );     

    public:
           
        //! Function that execute the algorithm operator that executes the algorithm.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method). 
           \param setToWord  transform words of the language studied in sets. 
           \param stopIte functor stop that stop the execution of apriori before the end.
           \param setToWordSave  transform for output the sets find by the algorithm in words of the language.  
           \param listInterestItems list of all the interesting items (set representation).             
        */
        template< class InitFunctor, class Predicate, class OutputTheory, class OutputBdP, class OutputBdN, class f,  class StopIteration, class f2 >   
        void executeAlgo( InitFunctor & init, Predicate * pred, OutputTheory * theory, OutputBdP * bdP, OutputBdN * bdN, f & wordToSet, StopIteration * stopIte, f2 & wordToSetSave, deque<SetsType> * listInteresItems = 0);


           
        //! Constructor           
        Apriori(){verbose=false;}
        
        // ! Destructor
        ~Apriori(){ } 
        
        //! Functor operator that executes the algorithm.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
           \param wordToSet  transform words of the language studied in sets. 
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN, class f   >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN, f & wordToSet )
        {
             executeAlgo( init, &pred, theory, bdP, bdN, wordToSet, (NoStopIteration * ) 0, wordToSet ) ;             
        }   
        
        //! Functor operator that executes the algorithm.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN   >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN) 
        {
             Id identity;
             executeAlgo( init, &pred, theory, bdP, bdN, identity, (NoStopIteration * ) 0, identity ) ;             
        }       
        
      
        
        //! Functor operator that executes the algorithm and stop his execution when the functor passed in parameter return false.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
           \param stopIte functor stop that stop the execution of apriori before the end.
           \param wordToSet  transform words of the language studied in sets.            
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN, class f, class StopIteration >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN, StopIteration * stopIte, f & wordToSet  ) 
        {
             executeAlgo( init, &pred, theory, bdP, bdN, wordToSet,  stopIte, wordToSet) ;             
        }
                
        
        //! Functor operator that executes the algorithm and stop his execution when the functor passed in parameter return false.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
           \param stopIte functor stop that stop the execution of apriori before the end.
           \param wordToSet  transform words of the language studied in sets.            
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN, class StopIteration >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN, StopIteration * stopIte   ) 
        {
             Id identity;
             executeAlgo( init, &pred, theory, bdP, bdN, identity, stopIte, identity) ;             
        }
               
      
};


// ----------------------------------------------------------------------------------------------

//! Function that execute the algorithm operator that executes the algorithm.
/**
   \param init functor initializing the interesting items wrt predicate.
   \param pred the predicate 
   \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
   \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
   \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method). 
   \param setToWord  transform words of the language studied in sets. 
   \param stopIte functor stop that stop the execution of apriori before the end.
   \param setToWordSave  transform for output the sets find by the algorithm in words of the language.    
   \param listInterestItems list of all the interesting items (set representation).                
*/
template< class SetsType ,class Measure,  class Cand_DataStruct  > template< class InitFunctor, class Predicate, class OutputTheory, class OutputBdP, class OutputBdN,  class f,  class StopIteration, class f2 > 
void Apriori<  SetsType,  Measure,  Cand_DataStruct >::executeAlgo( InitFunctor & init, Predicate  * pred, OutputTheory * theory, OutputBdP * bdP, OutputBdN * bdN, f& wordToSet, StopIteration * stopIte, f2 & wordToSetSave, deque<SetsType> * listInteresItems )
{
    clock_t start, startall ;
    int nbSet ;
    bool stop = false ;
    
    startall = clock();  
     
     
    int level = 1; // current level of the levelwise exploration of the search space

    if( verbose ) cout<<" LEVEL :"<<level;
    
    start = clock();  
    
    // find the basics interesting elements
    init() ;
    
    // insert the elements (and eventually transform in set)  in the set of candidates       
    for_each( init.listElements.begin(), init.listElements.end(), initCandidates<f>( candidates, wordToSet ) ) ;
    
    nbSet = candidates.size() ;
    
    if( verbose ) cout<<" Generate ["<<(clock()-start)/CLOCKS_PER_SEC<<"s]  Cand:"<<candidates.size();
    
    start = clock();
    
    // Preprocessing of the candidates
    pred->preProcessing( candidates, wordToSet );

    if( verbose ) cout<<" Pre processing ["<<(clock()-start)/CLOCKS_PER_SEC<<"s] ";
    

    // update the stop functor with the actual  information about the execution
    if( stopIte )
        stopIte->update( candidates ) ;
    
    start = clock();    
                         
    // Test candidates wrt the predicate and "prune"  bad ones (not delete right now but marked as bad ones)         
    nbSet -= prune( candidates, pred, theory, bdN, wordToSet, wordToSetSave, listInteresItems );
            
    if( verbose ) cout<<" Prune ["<<(clock()-start)/CLOCKS_PER_SEC<<"s] Theory:"<<nbSet;
   
    start = clock();
    
    // Postprocessing of the candidates
    pred->postProcessing( candidates, wordToSet );
 
    if( verbose ) cout<<" Post processing ["<<(clock()-start)/CLOCKS_PER_SEC<<"s] "<<endl; 

     while( candidates.length() == level &&  nbSet  > candidates.length()  &&  ( !stopIte || ! ( stop =(*stopIte)( candidates ) ) ) )
     {
      
         if( verbose ) cout<<" LEVEL :"<<level+1;   

         start = clock();    
                   
         // Candidate generation using interseting precedent elements
         nbSet = candidatesGeneration( candidates, level ) ;

         if( verbose ) cout<<" Generate ["<<(clock()-start)/CLOCKS_PER_SEC<<"s]  Cand:"<<nbSet;
    
         if( candidates.length() == level+1 ) // new candidates have been generated
         {
            start = clock();
             
            // Preprocessing of the candidates
            pred->preProcessing( candidates, wordToSet );
            
            if( verbose ) cout<<" Pre processing ["<<(clock()-start)/CLOCKS_PER_SEC<<"s] ";
 
            // update the stop functor with the actual  information about the execution
            if( stopIte )
                stopIte->update( candidates ) ;
            
            start = clock();    
                                 
            // Test candidates wrt the predicate and "prune"  bad ones (not delete right now but marked as bad ones)         
            nbSet -= prune( candidates, pred, theory, bdN, wordToSet, wordToSetSave );
                    
            if( verbose ) cout<<" Prune ["<<(clock()-start)/CLOCKS_PER_SEC<<"s] Theory:"<<nbSet;
            
            start = clock(); 
            
            // Postprocessing of the candidates
            pred->postProcessing( candidates, wordToSet );
            
            if( verbose ) cout<<" Post processing ["<<(clock()-start)/CLOCKS_PER_SEC<<"s] ";
 
         }             
         ++level ;
         
         if( verbose ) cout<<endl;  
     } 
     
     if( bdP )  // store the lements of the positive border
     {               
         filter( candidates ) ; // filter the elements of the positive border

         for( typename Cand_DataStruct::iterator it = candidates.beginLeaf() ; it != candidates.end() ; it=it.nextLeaf() )
         {
              if( !stop  || level > it.length()  )  // if the algorithms can't generate candidates -> all the positive border had been discovered
                                                    // if the algorithms had been stopped -> the last level  explored may contain frequent itemsets not in Bd+ 
                         bdP->push_back( * wordToSetSave.inverse( it), it.measure() ) ;    
         }
     }   
     
     if( verbose ){ cout<<endl; cout<<"Totat execution time ["<<(clock()-startall)/CLOCKS_PER_SEC<<"s]"<<endl; cout<<endl;} 
}

// ----------------------------------------------------------------------------------------------

//! Candidate generation phase of Apriori.      
/**
   \param cand set of candidates.
   \param level current size of the candidates.
   \return the number of sets generated.
*/
template<  class SetsType ,  class Measure,  class Cand_DataStruct  > 
int Apriori<  SetsType, Measure,   Cand_DataStruct>::candidatesGeneration( Cand_DataStruct & cand, int &level )
{
    SetsType elem  ;  
    int nb =0 ;

    vector<SetsType> buffer ;     // buffer used to find subsets
    buffer.reserve( level +1 ) ;  // initialized here to avoid unnecessary memory allocation
    
    typename Cand_DataStruct::iterator itLeaf = cand.beginLeaf(); // iterator on the leafs of the trie
    typename Cand_DataStruct::iterator itCand; // iterator on the leaf nodes with the same prefix (the first cand.length()-1 elements are identicals)

    while( itLeaf != cand.end() )    // go throw each the leaf and test if we can generate a candidate
    {
        itCand = itLeaf.nextChildNode(); // get the next  nodes used for a possible candidate generation

        while( itLeaf.length() == level  && itCand !=  typename Cand_DataStruct::iterator()  ) // here the default iterator represent an end iterator
        {
         
            if( testSubset( itLeaf, itCand, buffer ) )  // test if all the subsets of the set composed by node of itLeaf + node itCand are in the trie 
            {
                elem = itCand.element() ;  
                cand.addToNode( itLeaf, & elem, &elem+1 )  ;
                nb++;
            }
            itCand = itCand.nextChildNode(); 
        } 
        itLeaf = itLeaf.nextLeaf(); // get to the next leaf
    } 
    
    return nb;    
}

// ----------------------------------------------------------------------------------------------

//! Test if a set generated using the elements pointed by itPref and itLast is a candidate.
/**      
   \param itPref iterator on the prefix of the set to test. 
   \param itLast iterator on the elemnt to add to form the candidate set.    
   \param buffer container of size k used to test subset.    
   \return true if all the subsets of size k are already in the candidate.
*/
template< class SetsType , class Measure,   class Cand_DataStruct>  template< class Iterator >
bool Apriori<  SetsType, Measure,   Cand_DataStruct >::testSubset( Iterator & itPref, Iterator & itLast, vector<SetsType> & buffer ) 
{
    Iterator itParent ; // iterator on the parent node
    Iterator itSearch ; // iterator used to search elem in child nodes

    if( itLast != Iterator() )    // it is not the last child node of the parent node
    {
        buffer.push_back( itLast.element() ); //second subset (with same prefix) tested 
        buffer.push_back( itPref.element() );// save the item to search for subsets, ie first subset tested

        itParent = itLast.parentNode(); // go to parent node to test other subsets
        SetsType idParent = itParent.element();       
        itParent = itParent.parentNode();

        while( itParent !=  Iterator() )
        {
            int i = buffer.size() -1 ;

            itSearch = itParent.childNode(buffer[i]);

            while( i> 0 && itSearch != Iterator()  ) // go down the child nodes to find a subset
            {
                --i;

                itSearch = itSearch.childNode(buffer[i]);
             }    

            if( i!= 0 || itSearch == Iterator()  ) // a subset is not in the trie
            {
                 buffer.resize( 0 );
                 return false;
             }    

            buffer.push_back( idParent ) ; 
            
            idParent = itParent.element() ;

            itParent = itParent.parentNode() ;            
        }   
        buffer.resize( 0 ); // set the buffer to 0 but does not de allocate memory                                                                                            


    }          
    return true;
}

// ----------------------------------------------------------------------------------------------

//! Pruning generation phase of Apriori.
/**
   \param cand set of candidates.
   \param pred the predicate.
   \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).                         
   \param listInterestItems list of all the interesting items (set representation).                
   \return the number of candidates pruned.
*/
template< class SetsType , class Measure,    class Cand_DataStruct  > template< class Predicate, class OutputTheory , class OutputBdN, class f, class f2  >
int Apriori<  SetsType,  Measure,    Cand_DataStruct >::prune(  Cand_DataStruct & cand,  Predicate  * pred,  OutputTheory * theory  , OutputBdN * bdN, f & wordToSet, f2 & wordToSetSave, deque<SetsType> * listInteresItems)
{ 
       
    typename Cand_DataStruct::iterator itLeaf = cand.beginLeaf(); // iterator on the leafs of the trie
    typename Cand_DataStruct::iterator itNext ; // iterator on the next leaf of the trie
                
    int nbPrune = 0 ; // number of elements pruned
    
    while( itLeaf != cand.end() )    // go throw each the leaf and test if the candidates are true wrt the predicate
    {
        itNext = itLeaf.nextLeaf(); // get  the next leaf   
      
        if( itLeaf.length() == cand.length()  ) // we only test the last sets generated   
        {     

           if( !(*pred)( wordToSet.inverse(itLeaf), itLeaf.measure()  ) ) // the candidates does not respect the predicate
           { 
                if( bdN ) // we want to find the negative border
                {
                     bdN->push_back( * wordToSetSave.inverse(itLeaf) , itLeaf.measure() );                     
                }                          

                cand.eraseNode( itLeaf ) ; // erase and return the next node   
                ++nbPrune;                                    
           }  
           else
           {
                if( itLeaf.length() == 1 && listInteresItems )
                    listInteresItems->push_back( itLeaf.element() ) ; 

                if( theory ) // store all the theory
                  theory->push_back( * wordToSetSave.inverse(itLeaf),  itLeaf.measure() ) ;                     
           }
         
        }       
        itLeaf = itNext; // study to the next leaf   

    }      

    return nbPrune;         
} 

// ----------------------------------------------------------------------------------------------

//! Erase all the k-1 subsets of the set of size k coresponding to the iterator in parameter.
/**  
   \param cand contains the theory.     
   \param position iterator on the set. 
   \param buffer container of size k used to test subset.    
*/
template< class SetsType , class Measure,   class Cand_DataStruct  > template< class Iterator >
void Apriori<   SetsType,  Measure,  Cand_DataStruct >::eraseSubset( Cand_DataStruct & cand, Iterator & position,  vector<SetsType> & buffer ) 
{ 
     
    Iterator itParent ; // iterator on the parent node
    Iterator itSearch ; // iterator used to search elem in child nodes
    SetsType idParent ; // internal id
 
    buffer.push_back( position.element() );// save the item to search for subsets, ie first subset tested

    itParent = position.parentNode(); // go to parent node to test other subsets
    idParent = itParent.element();  
    itParent = itParent.parentNode();

    while( itParent !=  Iterator() )
    {
           
        int i = buffer.size() -1 ;

        itSearch = itParent.childNode(buffer[i]);

        while( i> 0 && itSearch != Iterator()  ) // go down the child nodes to find a subset
        {
            --i;
            itSearch = itSearch.childNode(buffer[i]);
         }    
 
        if( i== 0  && itSearch != Iterator() && itSearch.isaLeaf() ) // a subset is in the trie
        {  
            cand.erase( itSearch ) ;              
        }    

        buffer.push_back( idParent ) ; 
        
        idParent = itParent.element() ;

        itParent = itParent.parentNode() ;         
                  
    }   
    buffer.resize( 0 ); // set the buffer to 0 but does not de allocate memory                                                                                            
}

// ----------------------------------------------------------------------------------------------

//! Filter the elements of the positive border from the theory
/**
   \param cand contains the theory. 
*/
template<  class SetsType ,class Measure,   class Cand_DataStruct  >
void Apriori<  SetsType,  Measure,    Cand_DataStruct >::filter( Cand_DataStruct & cand )
{
    int nb =0 ;

    vector<SetsType> buffer ;                     // buffer used to find subsets
    buffer.reserve( cand.length() ) ;  // initialized here to avoid unnecessary memory allocation
    
    typename Cand_DataStruct::iterator itLeaf = cand.rbeginLeaf(); // iterator on the leafs of the trie

    while( itLeaf != cand.end() )    // go throw each the leaf and test if we can generate a candidate
    {                
        eraseSubset(  cand, itLeaf, buffer );  // test if all the subsets of the set composed by node of itLeaf + node itCand are in the trie 
       
        itLeaf = itLeaf.rnextLeaf(); // get to the next leaf
    }                        
}



#endif
