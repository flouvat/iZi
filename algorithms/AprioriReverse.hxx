/*
 *  Copyright (C) 2006 Frédéric Flouvat
 *  Written by Frédéric Flouvat
 *  Updated by Frédéric Flouvat
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License
 *  as published by the Free Software Foundation; either version 2
 *  of the License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 */
 
#ifndef APRIORIREVERSE_HXX
#define APRIORIREVERSE_HXX

#include "Apriori.hxx"

 

//! Functor finding the theory and/or the negative border and/or the positive border using the Apriori strategy but with a top down exploration of the search space.
/**
    Moreover this class enables to stop the execution of the algorithm at an iteration wrt to a user defined functor.
    The template parameter SetsType represents the type of the sets representing the elements of the language.
    The template parameter Measure is the type of the value eventually associated with the word of the language.
    The template parameter Cand_DataStruct is the data structure type used to store the candidates generated by the algorithms.
    The template parameter Word represents the type of the elements of the language.    
*/
template< class SetsType=int, class Measure=Boolean, class Word = vector< SetsType >,  class Cand_DataStruct = PTree<SetsType,Measure> >
class AprioriReverse: public Apriori<SetsType,Measure,Cand_DataStruct>
{
      //! Class used  when there is no stopIteration functor in Apriori
        class NoStopIteration
        {
            public:
                int level;
                   
                void update(  Cand_DataStruct & candidates ) {}       
                bool operator() ( Cand_DataStruct & candidates ) {return false;}                   
        };      
 
        
    public:
           
        //! Constructor           
        AprioriReverse():Apriori<SetsType,Measure,Cand_DataStruct>(){}
        
        // ! Destructor
        ~AprioriReverse(){ } 
        
        //! Functor operator that executes the algorithm.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
           \param wordToSet  transform words of the language studied in sets. 
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN, class f   >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN, f & wordToSet )
        {
             Complement< SetsType > complem;
             TransformElement< Complement< SetsType >, SetsType, f, Word > trans( &wordToSet, &complem ) ;
             
             this->executeAlgo( init, &pred, theory, bdP, bdN, trans, (NoStopIteration * ) 0, trans ) ;             
        }   
        
        //! Functor operator that executes the algorithm.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN   >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN) 
        {
             Complement< SetsType > complem;
             this->executeAlgo( init, &pred, theory, bdP, bdN, complem, (NoStopIteration * ) 0, complem ) ;             
        }       
        
      
        
        //! Functor operator that executes the algorithm and stop his execution when the functor passed in parameter return false.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
           \param stopIte functor stop that stop the execution of the algorithm before the end.
           \param wordToSet  transform words of the language studied in sets.            
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN, class f, class StopIteration >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN, StopIteration * stopIte, f & wordToSet  ) 
        {
             Complement< SetsType > complem;
             TransformElement< Complement< SetsType >, SetsType, f, Word > trans( &wordToSet, &complem ) ;
             
             this->executeAlgo( init, &pred, theory, bdP, bdN, trans,  stopIte, trans) ;             
        }
        
        //! Functor operator that executes the algorithm and stop his execution when the functor passed in parameter return false.
        /**
           \param init functor initializing the interesting items wrt predicate.
           \param pred the predicate 
           \param theory output the theory in the given objet (must have a push_back( container, measure ) method).
           \param bdP output the positive border in the given objet (must have a push_back( container, measure ) method).
           \param bdN output the negative border in the given objet (must have a push_back( container, measure ) method).  
           \param stopIte functor stop that stop the execution of the algorithm before the end.
           \param wordToSet  transform words of the language studied in sets.            
        */
        template<  class InitFunctor, class Predicate, class OutputTheory , class OutputBdP, class OutputBdN, class StopIteration >
        void operator() (  InitFunctor & init, Predicate  & pred, OutputTheory * theory , OutputBdP * bdP, OutputBdN * bdN, StopIteration * stopIte   ) 
        {
             Complement< SetsType > complem;
             this->executeAlgo( init, &pred, theory, bdP, bdN, complem, stopIte, complem) ;             
        }

        
      
};


#endif
