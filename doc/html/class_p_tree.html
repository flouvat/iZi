<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Easy prototyping of pattern mining algorithms: PTree&lt; SetsType, T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6-NO -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>PTree&lt; SetsType, T &gt; Class Template Reference</h1><!-- doxytag: class="PTree" -->Template class representing a trie data structure of integer.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;PTree.hxx&gt;</code>
<p>
<a href="class_p_tree-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa29b0935d154c06ff0dfcacbff2d683"></a><!-- doxytag: member="PTree::iterator" ref="aa29b0935d154c06ff0dfcacbff2d683" args="" -->
typedef <a class="el" href="class_it_p_tree.html">ItPTree</a>&lt; SetsType, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#aa29b0935d154c06ff0dfcacbff2d683">iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used to have the same syntax tha the STL. <br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="36e06775df6b20cad49bc53612744f33"></a><!-- doxytag: member="PTree::PTree" ref="36e06775df6b20cad49bc53612744f33" args="(Node&lt; SetsType, T &gt; *inHead=0, int inSize=0, int inHeight=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#36e06775df6b20cad49bc53612744f33">PTree</a> (<a class="el" href="class_node.html">Node</a>&lt; SetsType, T &gt; *inHead=0, int inSize=0, int inHeight=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="baf9201e7e17e366e1daaf82e4c059c5"></a><!-- doxytag: member="PTree::PTree" ref="baf9201e7e17e366e1daaf82e4c059c5" args="(const PTree &amp;t)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#baf9201e7e17e366e1daaf82e4c059c5">PTree</a> (const <a class="el" href="class_p_tree.html">PTree</a> &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d8d9d39e2e7cea5c88c56a6e2d99f83"></a><!-- doxytag: member="PTree::~PTree" ref="8d8d9d39e2e7cea5c88c56a6e2d99f83" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#8d8d9d39e2e7cea5c88c56a6e2d99f83">~PTree</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Container&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_tree.html#a00717d40a6aa709644759370ccb0382">push_back</a> (Container &amp;setElement, T nb=T(1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a set of element in the trie.  <a href="#a00717d40a6aa709644759370ccb0382"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_tree.html#728345ce3e2c137ce2e16258847004be">push_back</a> (InputIterator first, InputIterator last, T nb=T(1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a set of element in the trie.  <a href="#728345ce3e2c137ce2e16258847004be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#2e9e4620ff40789547e6a5fdbe5eb8e9">erase</a> (<a class="el" href="class_it_p_tree.html">iterator</a> &amp;position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase a set in the trie.  <a href="#2e9e4620ff40789547e6a5fdbe5eb8e9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Container&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_tree.html#09c1a7a6dec73c9cb75420f4d9c5a161">addToNode</a> (<a class="el" href="class_it_p_tree.html">iterator</a> &amp;position, Container &amp;setElement, T nb=T(1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a set of element to the node pointed by an iterator.  <a href="#09c1a7a6dec73c9cb75420f4d9c5a161"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_p_tree.html#cbf41b66e32c5de9230f93d03c5785af">addToNode</a> (<a class="el" href="class_it_p_tree.html">iterator</a> &amp;position, InputIterator first, InputIterator last, T nb=T(1))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a set of element to the node pointed by an iterator.  <a href="#cbf41b66e32c5de9230f93d03c5785af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_it_p_tree.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#8d8b9a315dc17b7b13a18dcb81d99f0f">eraseNode</a> (<a class="el" href="class_it_p_tree.html">iterator</a> &amp;it)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase the node under the iterator.  <a href="#8d8b9a315dc17b7b13a18dcb81d99f0f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9be852a43758de579be2642e5dc82334"></a><!-- doxytag: member="PTree::beginLeaf" ref="9be852a43758de579be2642e5dc82334" args="()" -->
<a class="el" href="class_it_p_tree.html">ItPTree</a>&lt; SetsType, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#9be852a43758de579be2642e5dc82334">beginLeaf</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator on the first leaf of the trie (exploring the trie from the left to the right). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="61ab00242ada00f83f6210efa337e065"></a><!-- doxytag: member="PTree::rbeginLeaf" ref="61ab00242ada00f83f6210efa337e065" args="()" -->
<a class="el" href="class_it_p_tree.html">ItPTree</a>&lt; SetsType, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#61ab00242ada00f83f6210efa337e065">rbeginLeaf</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator on the first leaf of the trie (exploring the trie from the right to the left). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7a13989068c070cd0c63517859aff760"></a><!-- doxytag: member="PTree::beginRoot" ref="7a13989068c070cd0c63517859aff760" args="()" -->
<a class="el" href="class_it_p_tree.html">ItPTree</a>&lt; SetsType, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#7a13989068c070cd0c63517859aff760">beginRoot</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator on the root node of the trie. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3b8dac8ae570e9194aeece6fb1de32a2"></a><!-- doxytag: member="PTree::begin" ref="3b8dac8ae570e9194aeece6fb1de32a2" args="()" -->
<a class="el" href="class_it_p_tree.html">ItPTree</a>&lt; SetsType, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#3b8dac8ae570e9194aeece6fb1de32a2">begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator on the first element stored. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4bed11f5f1b7c6a8821cb962cf174751"></a><!-- doxytag: member="PTree::end" ref="4bed11f5f1b7c6a8821cb962cf174751" args="()" -->
<a class="el" href="class_it_p_tree.html">ItPTree</a>&lt; SetsType, T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#4bed11f5f1b7c6a8821cb962cf174751">end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator on the element after the last element stored. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2ac4b383a5a842b40a397dd5396bab6"></a><!-- doxytag: member="PTree::length" ref="c2ac4b383a5a842b40a397dd5396bab6" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#c2ac4b383a5a842b40a397dd5396bab6">length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the length of the longest branch of the trie. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9a7994ba4a4eafdd56ad2a2ed2016e1"></a><!-- doxytag: member="PTree::size" ref="d9a7994ba4a4eafdd56ad2a2ed2016e1" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#d9a7994ba4a4eafdd56ad2a2ed2016e1">size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of elements in the trie. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95d13dd8e75352b21fbcfdb6cad4feb5"></a><!-- doxytag: member="PTree::setSize" ref="95d13dd8e75352b21fbcfdb6cad4feb5" args="(int inSize)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#95d13dd8e75352b21fbcfdb6cad4feb5">setSize</a> (int inSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the trie to a given value. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_p_tree.html">PTree</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#0b0f87710d37e03751bb0fc07b109464">operator=</a> (const <a class="el" href="class_p_tree.html">PTree</a> &amp;inPTree)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affectation operator.  <a href="#0b0f87710d37e03751bb0fc07b109464"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0bbb952dd9822a775e4454c3a1ef5bda"></a><!-- doxytag: member="PTree::operator&lt;" ref="0bbb952dd9822a775e4454c3a1ef5bda" args="(const PTree &amp;inTrie) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#0bbb952dd9822a775e4454c3a1ef5bda">operator&lt;</a> (const <a class="el" href="class_p_tree.html">PTree</a> &amp;inTrie) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Operator &lt; to process itemsets near the positive border. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="009d68e1ac08d2d87697ffa1ae017984"></a><!-- doxytag: member="PTree::deleteChildren" ref="009d68e1ac08d2d87697ffa1ae017984" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#009d68e1ac08d2d87697ffa1ae017984">deleteChildren</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method that deletes recursively the sub tree of this node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce39ce1f3afba5b22cb95e15ea3b8d6c"></a><!-- doxytag: member="PTree::getHead" ref="ce39ce1f3afba5b22cb95e15ea3b8d6c" args="() const " -->
<a class="el" href="class_node.html">Node</a>&lt; SetsType, T &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#ce39ce1f3afba5b22cb95e15ea3b8d6c">getHead</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the root node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="380b31580b00ad7c093ceb3da0915582"></a><!-- doxytag: member="PTree::setHead" ref="380b31580b00ad7c093ceb3da0915582" args="(Node&lt; SetsType, T &gt; *inHead)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#380b31580b00ad7c093ceb3da0915582">setHead</a> (<a class="el" href="class_node.html">Node</a>&lt; SetsType, T &gt; *inHead)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the root node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="823d49f32572e6973cea7f693b28876e"></a><!-- doxytag: member="PTree::setHeight" ref="823d49f32572e6973cea7f693b28876e" args="(int inHeight)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#823d49f32572e6973cea7f693b28876e">setHeight</a> (int inHeight)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the height of the tree. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_p_tree.html">PTree</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#a3a65704846f2afb0005ec7b08f300ce">trMinOpt</a> (int minEdge, int maxTrans)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method which calcul the minimal transversal of this set of set.  <a href="#a3a65704846f2afb0005ec7b08f300ce"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a107b599ab3a2a57b350916423ea232e"></a><!-- doxytag: member="PTree::recode" ref="a107b599ab3a2a57b350916423ea232e" args="" -->
static <a class="el" href="class_recode_to_int.html">RecodeToInt</a>&lt; SetsType &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#a107b599ab3a2a57b350916423ea232e">recode</a> = <a class="el" href="class_recode_to_int.html">RecodeToInt</a>&lt;SetsType&gt;()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">recode functor used to recode all the itemsets inserted in int and to keep the original order of the itemsets. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0e7cd51500557bb0269d221bd9ffc88e"></a><!-- doxytag: member="PTree::nbsets" ref="0e7cd51500557bb0269d221bd9ffc88e" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#0e7cd51500557bb0269d221bd9ffc88e">nbsets</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of sets of integers in the trie. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="11613cc6da516052c27239b78dacdc5c"></a><!-- doxytag: member="PTree::height" ref="11613cc6da516052c27239b78dacdc5c" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#11613cc6da516052c27239b78dacdc5c">height</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Height of the trie. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3761bcbfb42d1376697cc315de0d19ed"></a><!-- doxytag: member="PTree::head" ref="3761bcbfb42d1376697cc315de0d19ed" args="" -->
<a class="el" href="class_node.html">Node</a>&lt; SetsType, T &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#3761bcbfb42d1376697cc315de0d19ed">head</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Root node of the trie. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="903af7ba64521b8f0bd0df111679c5ea"></a><!-- doxytag: member="PTree::ItPTree&lt; SetsType, T &gt;" ref="903af7ba64521b8f0bd0df111679c5ea" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_p_tree.html#903af7ba64521b8f0bd0df111679c5ea">ItPTree&lt; SetsType, T &gt;</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class SetsType, class T = Boolean&gt;<br>
 class PTree&lt; SetsType, T &gt;</h3>

Template class representing a trie data structure of integer. 
<p>
This class store sets of integers in a trie. The integers are stored in a "bool vector" data strucuture in the nodes. If ith value of the vector is not empty, it means that the element i is in the node<p>
The template parameter SetsType represents the type of the elements inserted in the trie. The template parameter represents the type of the "bool vector" used to represents the presence or not of an element. For example bool to only store the presence or not of the element, int to store an integer measure (such as the support)... 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="cbf41b66e32c5de9230f93d03c5785af"></a><!-- doxytag: member="PTree::addToNode" ref="cbf41b66e32c5de9230f93d03c5785af" args="(iterator &amp;position, InputIterator first, InputIterator last, T nb=T(1))" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T = Boolean&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class InputIterator&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::addToNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_p_tree.html">iterator</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>nb</em> = <code>T(1)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a set of element to the node pointed by an iterator. 
<p>
The template parameter represents a container of integers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>iterator on the node where the set must be inserted (the iterator is not mover during the operation). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator on the first element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator on the element after the last </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb</em>&nbsp;</td><td>the number of times the set is inserted </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="09c1a7a6dec73c9cb75420f4d9c5a161"></a><!-- doxytag: member="PTree::addToNode" ref="09c1a7a6dec73c9cb75420f4d9c5a161" args="(iterator &amp;position, Container &amp;setElement, T nb=T(1))" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T = Boolean&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class Container&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::addToNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_p_tree.html">iterator</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Container &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>setElement</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>nb</em> = <code>T(1)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a set of element to the node pointed by an iterator. 
<p>
The template parameter represents a container of integers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>iterator on the node where the set must be inserted(the iterator is not mover during the operation) . </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setElement</em>&nbsp;</td><td>the set of element (internal id ) to insert in the trie. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb</em>&nbsp;</td><td>the number of times the set is inserted </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="2e9e4620ff40789547e6a5fdbe5eb8e9"></a><!-- doxytag: member="PTree::erase" ref="2e9e4620ff40789547e6a5fdbe5eb8e9" args="(iterator &amp;position)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T = Boolean&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::erase           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_p_tree.html">iterator</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>position</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase a set in the trie. 
<p>
Delete a branch of the trie. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>erase the nodes corresponding to the given iterator (which is on a leaf node). </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="8d8b9a315dc17b7b13a18dcb81d99f0f"></a><!-- doxytag: member="PTree::eraseNode" ref="8d8b9a315dc17b7b13a18dcb81d99f0f" args="(iterator &amp;it)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T = Boolean&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_p_tree.html">iterator</a> <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::eraseNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_p_tree.html">iterator</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>it</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Erase the node under the iterator. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>erase the node at position it. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>iterator on the next node (ie, the next child node wrt lex order if exits, else the parent node ) . </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="0b0f87710d37e03751bb0fc07b109464"></a><!-- doxytag: member="PTree::operator=" ref="0b0f87710d37e03751bb0fc07b109464" args="(const PTree &amp;inPTree)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T = Boolean&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_p_tree.html">PTree</a>&amp; <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::operator=           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt; &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>inPTree</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Affectation operator. 
<p>
cout&lt;&lt;"SUB  : "; for_each( it-&gt;<a class="el" href="class_p_tree.html#3b8dac8ae570e9194aeece6fb1de32a2">begin()</a>, it-&gt;<a class="el" href="class_p_tree.html#4bed11f5f1b7c6a8821cb962cf174751">end()</a>, printContainer() ); cout&lt;&lt;it.measure()&lt;&lt;endl; getchar();     </td>
  </tr>
</table>
<a class="anchor" name="728345ce3e2c137ce2e16258847004be"></a><!-- doxytag: member="PTree::push_back" ref="728345ce3e2c137ce2e16258847004be" args="(InputIterator first, InputIterator last, T nb=T(1))" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T = Boolean&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class InputIterator&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::push_back           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>InputIterator&nbsp;</td>
          <td class="mdname" nowrap> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>nb</em> = <code>T(1)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a set of element in the trie. 
<p>
The template parameter represents the input iterators on the integers to insert int the trie. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>iterator on the first element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>iterator on the element after the last </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb</em>&nbsp;</td><td>the number of times the set is inserted </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if a new set has been inserted (false if it was already in the trie) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a00717d40a6aa709644759370ccb0382"></a><!-- doxytag: member="PTree::push_back" ref="a00717d40a6aa709644759370ccb0382" args="(Container &amp;setElement, T nb=T(1))" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T = Boolean&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class Container&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::push_back           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Container &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>setElement</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname" nowrap> <em>nb</em> = <code>T(1)</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a set of element in the trie. 
<p>
This function corresponds to the classic <a class="el" href="class_p_tree.html#a00717d40a6aa709644759370ccb0382">push_back( )</a> function od STL container. The template parameter represents a container of integers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>setElement</em>&nbsp;</td><td>the set of element to insert in the trie. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nb</em>&nbsp;</td><td>the number of times the set is inserted </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if a new set has been inserted (false if it was already in the trie) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a3a65704846f2afb0005ec7b08f300ce"></a><!-- doxytag: member="PTree::trMinOpt" ref="a3a65704846f2afb0005ec7b08f300ce" args="(int minEdge, int maxTrans)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt; * <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, T &gt;::trMinOpt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>minEdge</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxTrans</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method which calcul the minimal transversal of this set of set. 
<p>
This method is optimised for our problem since it delete all the transversal of cardinality &lt;= maxTrans and do not conisder edge of size &gt;= minEdge     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>F:/iZi/dataStructures/trie/PTree.hxx</ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 27 15:54:03 2007 for Easy prototyping of pattern mining algorithms by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO </small></address>
</body>
</html>
