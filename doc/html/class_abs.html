<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Easy prototyping of pattern mining algorithms: Abs&lt; SetsType, Measure, Cand_DataStruct &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6-NO -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>Abs&lt; SetsType, Measure, Cand_DataStruct &gt; Class Template Reference</h1><!-- doxytag: class="Abs" -->Functor finding the negative border Bd- and/or the positive border Bd+ using the algorithm ABS.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;Abs.hxx&gt;</code>
<p>
<p>Inheritance diagram for Abs&lt; SetsType, Measure, Cand_DataStruct &gt;:
<p><center><img src="class_abs.png" usemap="#Abs< SetsType, Measure, Cand_DataStruct >_map" border="0" alt=""></center>
<map name="Abs< SetsType, Measure, Cand_DataStruct >_map">
<area href="class_abs_reverse.html" alt="AbsReverse< SetsType, Measure, Word, Cand_DataStruct >" shape="rect" coords="0,56,360,80">
</map>
<a href="class_abs-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b9e1bb01229ec95da6b1a5f533dd7151"></a><!-- doxytag: member="Abs::Abs" ref="b9e1bb01229ec95da6b1a5f533dd7151" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#b9e1bb01229ec95da6b1a5f533dd7151">Abs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="72d51b48cb02d0fbb3815d6f8dbf67e6"></a><!-- doxytag: member="Abs::~Abs" ref="72d51b48cb02d0fbb3815d6f8dbf67e6" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#72d51b48cb02d0fbb3815d6f8dbf67e6">~Abs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InitFunctor, class Predicate, class StopIteration, class OutputBdP, class OutputBdN, class f&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abs.html#991fe73b7db6f50b75e434631187ec9a">operator()</a> (InitFunctor &amp;init, <a class="el" href="class_predicate.html">Predicate</a> &amp;pred, StopIteration *stopDualization, OutputBdP *outBdP, OutputBdN *outBdN, f &amp;wordToSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor operator that executes the algorithm.  <a href="#991fe73b7db6f50b75e434631187ec9a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InitFunctor, class Predicate, class StopIteration, class OutputBdP, class OutputBdN&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abs.html#1cb8186e971cbb42b54d29bab5ba1e01">operator()</a> (InitFunctor &amp;init, <a class="el" href="class_predicate.html">Predicate</a> &amp;pred, StopIteration *stopDualization, OutputBdP *outBdP, OutputBdN *outBdN)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor operator that executes the algorithm.  <a href="#1cb8186e971cbb42b54d29bab5ba1e01"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="346a3f491c7896baa2669113764d9fa7"></a><!-- doxytag: member="Abs::verbose" ref="346a3f491c7896baa2669113764d9fa7" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#346a3f491c7896baa2669113764d9fa7">verbose</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="class_boolean.html">Boolean</a> to print to screen some informations during the execution (default false). <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InitFunctor, class Predicate, class StopIteration, class OutputBdP, class OutputBdN, class Error, class f&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abs.html#33917103181d75de02278cb345c96c1a">executeAlgorithm</a> (InitFunctor &amp;init, <a class="el" href="class_predicate.html">Predicate</a> *pred, StopIteration *stopDualization, OutputBdP *outBdP, OutputBdN *outBdN, Error *error, f &amp;wordToSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute the algorithm.  <a href="#33917103181d75de02278cb345c96c1a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate, class Error, class f&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abs.html#18e3c9003dca0c22177631287ce60aa5">processOptGenSub</a> (<a class="el" href="class_predicate.html">Predicate</a> *pred, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *complSet, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *opt, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *tr, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *freqTr, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *subSet, int size, f &amp;wordToSet, Error *error)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process the optimist positive border.  <a href="#18e3c9003dca0c22177631287ce60aa5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#4069503604644bb7ddb2404a47098663">moveTransFreq</a> (vectUI *itemset, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *tr, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *freqTr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method that move a minimal transversal which have "generated" an interesting set from the set of minimal transversals to another set.  <a href="#4069503604644bb7ddb2404a47098663"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate, class f&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abs.html#46ecf54530c316a639b3533386af9d4b">pruneCandidates</a> (<a class="el" href="class_predicate.html">Predicate</a> *pred, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *tr, int level, deqItCand &amp;lastBdNElem, f &amp;wordToSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prune the not interesting elements generated by the levelwise exploration.  <a href="#46ecf54530c316a639b3533386af9d4b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#41ebb2a6cc990dee19092f6ca21effa8">genCand</a> (<a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *subSet, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *inbdp)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method generating the candidates of the levelwise exploration.  <a href="#41ebb2a6cc990dee19092f6ca21effa8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate, class f&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abs.html#61298c6d5b7e4ff5192b2a68c52b701a">optApproach</a> (<a class="el" href="class_predicate.html">Predicate</a> *pred, set&lt; <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; &gt; *optIt, int lvl, f &amp;wordToSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method used to do the optimist approach based on "almost interesting" elements.  <a href="#61298c6d5b7e4ff5192b2a68c52b701a"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Predicate, class f&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_abs.html#9756459bbd5a86de592167e310c576fa">pruneCandidatesOpt</a> (<a class="el" href="class_predicate.html">Predicate</a> *pred, <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *tr, f &amp;wordToSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">"Prune" the interesting elements when exploring almost interesting elements.  <a href="#9756459bbd5a86de592167e310c576fa"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e5143798f9be145d0712d57d553915c2"></a><!-- doxytag: member="Abs::apriori" ref="e5143798f9be145d0712d57d553915c2" args="" -->
<a class="el" href="class_apriori.html">Apriori</a>&lt; SetsType, Measure,<br>
 Cand_DataStruct &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#e5143798f9be145d0712d57d553915c2">apriori</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Algorithm apriori used for the bottom up initialization. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84861429e931d82ff76926e5709ecd3f"></a><!-- doxytag: member="Abs::bdN" ref="84861429e931d82ff76926e5709ecd3f" args="" -->
Cand_DataStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#84861429e931d82ff76926e5709ecd3f">bdN</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Negative border. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="891257e049d0299337be5a48983a5297"></a><!-- doxytag: member="Abs::bdP" ref="891257e049d0299337be5a48983a5297" args="" -->
Cand_DataStruct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abs.html#891257e049d0299337be5a48983a5297">bdP</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Positive border. <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class SetsType = int, class Measure = Boolean, class Cand_DataStruct = PTree&lt;SetsType,Measure &gt;&gt;<br>
 class Abs&lt; SetsType, Measure, Cand_DataStruct &gt;</h3>

Functor finding the negative border Bd- and/or the positive border Bd+ using the algorithm ABS. 
<p>
The algorithme ("()" method)take in parameter: the initialisation functor, the predicate, the functor determining at which iteration the levelwise step is stop, the positive and/or negative borders (optional), the transformation function (optional).<p>
The method executeAlgorithm could be use to execute the algorithm. This method have another parameter to deal with "almost interesting elements" based on an error function passed i n parameter. These elements are considered as interesting during the iterations, and at the end they are used to do a top-down traversal of the search space to find the latests elements of Bd+.<p>
The template parameter SetsType represents the type of the elements of the set representation. The template parameter Measure is the type of the value eventually associated with the word of the language. The template parameter Cand_DataStruct is the data structure type used by the algorithms to manipulate the candidates generated. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="33917103181d75de02278cb345c96c1a"></a><!-- doxytag: member="Abs::executeAlgorithm" ref="33917103181d75de02278cb345c96c1a" args="(InitFunctor &amp;init, Predicate *pred, StopIteration *stopDualization, OutputBdP *outBdP, OutputBdN *outBdN, Error *error, f &amp;wordToSet)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class Measure, class Cand_DataStruct&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class InitFunctor, class Predicate, class StopIteration, class OutputBdP, class OutputBdN, class Error, class f&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::executeAlgorithm           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InitFunctor &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_predicate.html">Predicate</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>StopIteration *&nbsp;</td>
          <td class="mdname" nowrap> <em>stopDualization</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>OutputBdP *&nbsp;</td>
          <td class="mdname" nowrap> <em>outBdP</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>OutputBdN *&nbsp;</td>
          <td class="mdname" nowrap> <em>outBdN</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error *&nbsp;</td>
          <td class="mdname" nowrap> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>wordToSet</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute the algorithm. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>functor initializing the interesting items wrt predicate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stopDualization</em>&nbsp;</td><td>functor determining when the apiori execution must stop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdP</em>&nbsp;</td><td>output the positive border in the given objet (must have a push_back( container, measure ) method). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdN</em>&nbsp;</td><td>output the negative border in the given objet (must have a push_back( container, measure ) method). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>function processing if a not interesting element of the optimistic positive border is "almost interesting" </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="41ebb2a6cc990dee19092f6ca21effa8"></a><!-- doxytag: member="Abs::genCand" ref="41ebb2a6cc990dee19092f6ca21effa8" args="(PTree&lt; SetsType, Measure &gt; *subSet, PTree&lt; SetsType, Measure &gt; *inbdp)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class Measure, class Cand_DataStruct&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::genCand           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>subSet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>inbdp</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method generating the candidates of the levelwise exploration. 
<p>
Actually, this method delete all the subsets generated when processing the optimistic positive border which are included into one element of Bd+.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subSet</em>&nbsp;</td><td>subsets of size k+1 of the not interesting elements find in the optimistic positive border. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inbdp</em>&nbsp;</td><td>the positive border (all the elements of Bd+ found until the current iteration) </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="4069503604644bb7ddb2404a47098663"></a><!-- doxytag: member="Abs::moveTransFreq" ref="4069503604644bb7ddb2404a47098663" args="(vectUI *itemset, PTree&lt; SetsType, Measure &gt; *tr, PTree&lt; SetsType, Measure &gt; *freqTr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class Measure, class Cand_DataStruct&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::moveTransFreq           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">vectUI *&nbsp;</td>
          <td class="mdname" nowrap> <em>itemset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>tr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>freqTr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method that move a minimal transversal which have "generated" an interesting set from the set of minimal transversals to another set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>itemset</em>&nbsp;</td><td>set wich have generated an interesting element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tr</em>&nbsp;</td><td>set of the minimal transversals (those which have generated not interesting elements) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freqTr</em>&nbsp;</td><td>set of the minmal tranversals which have generated an interesting elements </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="1cb8186e971cbb42b54d29bab5ba1e01"></a><!-- doxytag: member="Abs::operator()" ref="1cb8186e971cbb42b54d29bab5ba1e01" args="(InitFunctor &amp;init, Predicate &amp;pred, StopIteration *stopDualization, OutputBdP *outBdP, OutputBdN *outBdN)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType = int, class Measure = Boolean, class Cand_DataStruct = PTree&lt;SetsType,Measure &gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class InitFunctor, class Predicate, class StopIteration, class OutputBdP, class OutputBdN&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::operator()           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InitFunctor &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_predicate.html">Predicate</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>StopIteration *&nbsp;</td>
          <td class="mdname" nowrap> <em>stopDualization</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>OutputBdP *&nbsp;</td>
          <td class="mdname" nowrap> <em>outBdP</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>OutputBdN *&nbsp;</td>
          <td class="mdname" nowrap> <em>outBdN</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Functor operator that executes the algorithm. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>functor initializing the interesting items wrt predicate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stopDualization</em>&nbsp;</td><td>functor determining when the apiori execution must stop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdP</em>&nbsp;</td><td>output the positive border in the given objet (must have a push_back( container, measure ) method). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdN</em>&nbsp;</td><td>output the negative border in the given objet (must have a push_back( container, measure ) method). </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="class_abs_reverse.html#783d932854ce93bd14518406996d8090">AbsReverse&lt; SetsType, Measure, Word, Cand_DataStruct &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="991fe73b7db6f50b75e434631187ec9a"></a><!-- doxytag: member="Abs::operator()" ref="991fe73b7db6f50b75e434631187ec9a" args="(InitFunctor &amp;init, Predicate &amp;pred, StopIteration *stopDualization, OutputBdP *outBdP, OutputBdN *outBdN, f &amp;wordToSet)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType = int, class Measure = Boolean, class Cand_DataStruct = PTree&lt;SetsType,Measure &gt;&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class InitFunctor, class Predicate, class StopIteration, class OutputBdP, class OutputBdN, class f&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::operator()           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InitFunctor &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>init</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_predicate.html">Predicate</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>StopIteration *&nbsp;</td>
          <td class="mdname" nowrap> <em>stopDualization</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>OutputBdP *&nbsp;</td>
          <td class="mdname" nowrap> <em>outBdP</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>OutputBdN *&nbsp;</td>
          <td class="mdname" nowrap> <em>outBdN</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>wordToSet</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Functor operator that executes the algorithm. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>init</em>&nbsp;</td><td>functor initializing the interesting items wrt predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stopDualization</em>&nbsp;</td><td>functor determining when the apiori execution must stop </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdP</em>&nbsp;</td><td>output the positive border in the given objet (must have a push_back( container, measure ) method). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bdN</em>&nbsp;</td><td>output the negative border in the given objet (must have a push_back( container, measure ) method). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wordToset</em>&nbsp;</td><td>transformation function </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="class_abs_reverse.html#d4e6aa7d0f2e50db5d5e75ab5801fd51">AbsReverse&lt; SetsType, Measure, Word, Cand_DataStruct &gt;</a>.    </td>
  </tr>
</table>
<a class="anchor" name="61298c6d5b7e4ff5192b2a68c52b701a"></a><!-- doxytag: member="Abs::optApproach" ref="61298c6d5b7e4ff5192b2a68c52b701a" args="(Predicate *pred, set&lt; PTree&lt; SetsType, Measure &gt; &gt; *optIt, int lvl, f &amp;wordToSet)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class Measure, class Cand_DataStruct&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class Predicate, class f&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">void <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::optApproach           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_predicate.html">Predicate</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>set&lt; <a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>optIt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>lvl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>wordToSet</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Method used to do the optimist approach based on "almost interesting" elements. 
<p>
From a set of sets in parameter, it founds all the maximals interesting sets of the sub lattice until a given level. the exploration of the search space id done level by level.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optIt</em>&nbsp;</td><td>set containing the almost interesting elements (strored by size) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lvl</em>&nbsp;</td><td>the "smallest" level to explore </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wordToset</em>&nbsp;</td><td>transformation function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="18e3c9003dca0c22177631287ce60aa5"></a><!-- doxytag: member="Abs::processOptGenSub" ref="18e3c9003dca0c22177631287ce60aa5" args="(Predicate *pred, PTree&lt; SetsType, Measure &gt; *complSet, PTree&lt; SetsType, Measure &gt; *opt, PTree&lt; SetsType, Measure &gt; *tr, PTree&lt; SetsType, Measure &gt; *freqTr, PTree&lt; SetsType, Measure &gt; *subSet, int size, f &amp;wordToSet, Error *error)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class Measure, class Cand_DataStruct&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class Predicate, class Error, class f&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::processOptGenSub           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_predicate.html">Predicate</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>complSet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>opt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>tr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>freqTr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>subSet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>wordToSet</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Error *&nbsp;</td>
          <td class="mdname" nowrap> <em>error</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Process the optimist positive border. 
<p>
All the interesting sets update Bd+ and the subests of the not interesting sets are generated. If the "almost interesting" elements are studied, this method save these elements in a particular data structure. To optimize the minimal transversal computation, minimal transversals which have generated an interesting element are stored separately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>complSet</em>&nbsp;</td><td>set of complements of the minimal transversals in the current iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt</em>&nbsp;</td><td>set used to store the almost interesting elments (not necessarly used) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tr</em>&nbsp;</td><td>set of the minimal transversals find until the current iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freqtr</em>&nbsp;</td><td>set of the minimal transversals find until the current iteration and which have generated an interesting element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>subSet</em>&nbsp;</td><td>strore the subsets of size k (current level of the levelwise approach) of the not interesting elements fond in the optimistic positive border </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>current level of the levelwise approach </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wordToset</em>&nbsp;</td><td>transformation function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>error</em>&nbsp;</td><td>function processing if a not interesting element of the optimistic positive border is "almost interesting" </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="46ecf54530c316a639b3533386af9d4b"></a><!-- doxytag: member="Abs::pruneCandidates" ref="46ecf54530c316a639b3533386af9d4b" args="(Predicate *pred, PTree&lt; SetsType, Measure &gt; *tr, int level, deqItCand &amp;lastBdNElem, f &amp;wordToSet)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class Measure, class Cand_DataStruct&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class Predicate, class f&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::pruneCandidates           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_predicate.html">Predicate</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>tr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>deqItCand &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>lastBdNElem</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>wordToSet</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prune the not interesting elements generated by the levelwise exploration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tr</em>&nbsp;</td><td>set of the candidates generated by the levelwise exploration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>current level of the levelwise exploration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBdNElem</em>&nbsp;</td><td>elements (iterators on) of the negative border found in the current iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wordToset</em>&nbsp;</td><td>transformation function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="9756459bbd5a86de592167e310c576fa"></a><!-- doxytag: member="Abs::pruneCandidatesOpt" ref="9756459bbd5a86de592167e310c576fa" args="(Predicate *pred, PTree&lt; SetsType, Measure &gt; *tr, f &amp;wordToSet)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType, class Measure, class Cand_DataStruct&gt; </td>
        </tr>
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class Predicate, class f&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">int <a class="el" href="class_abs.html">Abs</a>&lt; SetsType, Measure, Cand_DataStruct &gt;::pruneCandidatesOpt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="class_predicate.html">Predicate</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pred</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="class_p_tree.html">PTree</a>&lt; SetsType, Measure &gt; *&nbsp;</td>
          <td class="mdname" nowrap> <em>tr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>f &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>wordToSet</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
"Prune" the interesting elements when exploring almost interesting elements. 
<p>
The interesting elements are pruned for further exploration but stored in the positive border.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>the predicate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tr</em>&nbsp;</td><td>the set of candidates generated by the exploration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wordToset</em>&nbsp;</td><td>transformation function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>F:/iZi/algorithms/Abs.hxx</ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 27 15:54:02 2007 for Easy prototyping of pattern mining algorithms by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO </small></address>
</body>
</html>
