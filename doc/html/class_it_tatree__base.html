<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Easy prototyping of pattern mining algorithms: ItTatree_base&lt; SetsType &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6-NO -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<h1>ItTatree_base&lt; SetsType &gt; Class Template Reference</h1><!-- doxytag: class="ItTatree_base" -->Iterator on a <a class="el" href="class_tatree__base.html">Tatree_base</a> (trie data structure).  
<a href="#_details">More...</a>
<p>
<code>#include &lt;ItTatree_base.hxx&gt;</code>
<p>
<a href="class_it_tatree__base-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2d56f24bb02592eb1d548b0ab6af39cb"></a><!-- doxytag: member="ItTatree_base::ItTatree_base" ref="2d56f24bb02592eb1d548b0ab6af39cb" args="(Tatree_base&lt; SetsType &gt; *intrie=0)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#2d56f24bb02592eb1d548b0ab6af39cb">ItTatree_base</a> (<a class="el" href="class_tatree__base.html">Tatree_base</a>&lt; SetsType &gt; *intrie=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4ccd6aa674f6a9f6a79d11f5e827df82"></a><!-- doxytag: member="ItTatree_base::ItTatree_base" ref="4ccd6aa674f6a9f6a79d11f5e827df82" args="(const ItTatree_base &amp;it)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#4ccd6aa674f6a9f6a79d11f5e827df82">ItTatree_base</a> (const <a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;it)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy contructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b293a7e6a8ecb1f17dcd2bba5c9f26f2"></a><!-- doxytag: member="ItTatree_base::operator=" ref="b293a7e6a8ecb1f17dcd2bba5c9f26f2" args="(const ItTatree_base &amp;it)" -->
<a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#b293a7e6a8ecb1f17dcd2bba5c9f26f2">operator=</a> (const <a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;it)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Affectation operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c67bf39e9af3d2b8ee7ca3dbd34e1b7"></a><!-- doxytag: member="ItTatree_base::~ItTatree_base" ref="8c67bf39e9af3d2b8ee7ca3dbd34e1b7" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#8c67bf39e9af3d2b8ee7ca3dbd34e1b7">~ItTatree_base</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b8b4c04660ce0022167eae953b52b73"></a><!-- doxytag: member="ItTatree_base::operator==" ref="1b8b4c04660ce0022167eae953b52b73" args="(const ItTatree_base &amp;it) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#1b8b4c04660ce0022167eae953b52b73">operator==</a> (const <a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;it) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f73b720ada11494625c5be33f7852d5"></a><!-- doxytag: member="ItTatree_base::operator!=" ref="8f73b720ada11494625c5be33f7852d5" args="(const ItTatree_base &amp;it) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#8f73b720ada11494625c5be33f7852d5">operator!=</a> (const <a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;it) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Difference operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="56bc4c0350976556eb66d305c20283bb"></a><!-- doxytag: member="ItTatree_base::element" ref="56bc4c0350976556eb66d305c20283bb" args="()" -->
SetsType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#56bc4c0350976556eb66d305c20283bb">element</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function returning the id of the element in the current node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="44b5064f0430ec6d5e08cc9d4edc9168"></a><!-- doxytag: member="ItTatree_base::elementId" ref="44b5064f0430ec6d5e08cc9d4edc9168" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#44b5064f0430ec6d5e08cc9d4edc9168">elementId</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function returning the internal id of the element in the current node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3cb8b5a30e8b7292fa9a789fd06f5a09"></a><!-- doxytag: member="ItTatree_base::measure" ref="3cb8b5a30e8b7292fa9a789fd06f5a09" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#3cb8b5a30e8b7292fa9a789fd06f5a09">measure</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the measure store in the node associated to the set <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#f0ac7e5e53428400220df060dbcdd66a">rnextChild</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the iterator on the previous (wrt order of elements) child node of the current parent node.  <a href="#f0ac7e5e53428400220df060dbcdd66a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#5b89e54c0ffe5036b41f32842e4eb8b7">nextChild</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the iterator on the next (wrt order of elements) child node of the current parent node.  <a href="#5b89e54c0ffe5036b41f32842e4eb8b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#fb3bdc6147396c842dcedc385dc93f73">rbeginChildNode</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the iterator on the current node on the first in reverse order child node.  <a href="#fb3bdc6147396c842dcedc385dc93f73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#1f220df0efabdc43af17b18b676ff72e">beginChildNode</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the iterator on the current node on the first child node.  <a href="#1f220df0efabdc43af17b18b676ff72e"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="160cdf6cedc88b43a6bd05ad56f768cc"></a><!-- doxytag: member="ItTatree_base::node" ref="160cdf6cedc88b43a6bd05ad56f768cc" args="" -->
<a class="el" href="class_tatree_node.html">TatreeNode</a>&lt; SetsType &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#160cdf6cedc88b43a6bd05ad56f768cc">node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer on the current node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2c03dbde18a7eceb7821084245eca38f"></a><!-- doxytag: member="ItTatree_base::itElem" ref="2c03dbde18a7eceb7821084245eca38f" args="" -->
ItMapTTatree&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#2c03dbde18a7eceb7821084245eca38f">itElem</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator on current element. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a441b943cb27a2ecf58c394853213215"></a><!-- doxytag: member="ItTatree_base::trie" ref="a441b943cb27a2ecf58c394853213215" args="" -->
<a class="el" href="class_tatree__base.html">Tatree_base</a>&lt; SetsType &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#a441b943cb27a2ecf58c394853213215">trie</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Current trie. <br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d067db2add706706c659a83c3cbcf41"></a><!-- doxytag: member="ItTatree_base::Tatree_base&lt; SetsType &gt;" ref="4d067db2add706706c659a83c3cbcf41" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_it_tatree__base.html#4d067db2add706706c659a83c3cbcf41">Tatree_base&lt; SetsType &gt;</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class SetsType&gt;<br>
 class ItTatree_base&lt; SetsType &gt;</h3>

Iterator on a <a class="el" href="class_tatree__base.html">Tatree_base</a> (trie data structure). 
<p>
The operations on a <a class="el" href="class_tatree__base.html">Tatree_base</a> are limited. For example, we cannot directly acces to the transactions by using ++ and *. The advantage of that type of structure is that it is lighter than one with more operations. Consequently code dedicated to such class will be more efficient.<p>
The template parameter SetsType is the type of the element stored in the trie. The template parameter Container is the container use to store the set of elements. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="1f220df0efabdc43af17b18b676ff72e"></a><!-- doxytag: member="ItTatree_base::beginChildNode" ref="1f220df0efabdc43af17b18b676ff72e" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&amp; <a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&lt; SetsType &gt;::beginChildNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Move the iterator on the current node on the first child node. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the iterator on the child node. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="5b89e54c0ffe5036b41f32842e4eb8b7"></a><!-- doxytag: member="ItTatree_base::nextChild" ref="5b89e54c0ffe5036b41f32842e4eb8b7" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&amp; <a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&lt; SetsType &gt;::nextChild           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Move the iterator on the next (wrt order of elements) child node of the current parent node. 
<p>
If the current node is the root node return the end iterator. For efficiency reason the returne iterator does not contain the underlying set stored from the node. <dl compact><dt><b>Returns:</b></dt><dd>an iterator on the next (wrt order of elements) child node if exists, else return default iterator. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="fb3bdc6147396c842dcedc385dc93f73"></a><!-- doxytag: member="ItTatree_base::rbeginChildNode" ref="fb3bdc6147396c842dcedc385dc93f73" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&amp; <a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&lt; SetsType &gt;::rbeginChildNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Move the iterator on the current node on the first in reverse order child node. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>the iterator on the child node. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f0ac7e5e53428400220df060dbcdd66a"></a><!-- doxytag: member="ItTatree_base::rnextChild" ref="f0ac7e5e53428400220df060dbcdd66a" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class SetsType&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&amp; <a class="el" href="class_it_tatree__base.html">ItTatree_base</a>&lt; SetsType &gt;::rnextChild           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Move the iterator on the previous (wrt order of elements) child node of the current parent node. 
<p>
If the current node is the root node return the end iterator. For efficiency reason the returne iterator does not contain the underlying set stored from the node. <dl compact><dt><b>Returns:</b></dt><dd>an iterator on the previous (wrt order of elements) child node if exists, else return default iterator. </dd></dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>F:/iZi/dataStructures/trie/ItTatree_base.hxx</ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jun 27 15:54:03 2007 for Easy prototyping of pattern mining algorithms by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6-NO </small></address>
</body>
</html>
