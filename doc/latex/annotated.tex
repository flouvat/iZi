\section{Easy prototyping of pattern mining algorithms Class List}
Here are the classes, structs, unions and interfaces with brief descriptions:\begin{CompactList}
\item\contentsline{section}{{\bf Abs$<$ Sets\-Type, Measure, Cand\_\-Data\-Struct $>$} (Functor finding the negative border Bd- and/or the positive border Bd+ using the algorithm ABS )}{\pageref{class_abs}}{}
\item\contentsline{section}{{\bf Abs\-Reverse$<$ Sets\-Type, Measure, Word, Cand\_\-Data\-Struct $>$} (Functor finding the negative border Bd- and/or the positive border Bd+ using the algorithm ABS doing a top dow exploration of the search space )}{\pageref{class_abs_reverse}}{}
\item\contentsline{section}{{\bf Apriori$<$ Sets\-Type, Measure, Cand\_\-Data\-Struct $>$} (Functor finding the theory and/or the negative border and/or the positive border using the algorithm {\bf Apriori}{\rm (p.\,\pageref{class_apriori})} )}{\pageref{class_apriori}}{}
\item\contentsline{section}{{\bf Apriori$<$ Sets\-Type, Measure, Cand\_\-Data\-Struct $>$::init\-Candidates$<$ f $>$} (Initialize the set of candidates with the basic words of the language )}{\pageref{class_apriori_1_1init_candidates}}{}
\item\contentsline{section}{{\bf Apriori\-Reverse$<$ Sets\-Type, Measure, Word, Cand\_\-Data\-Struct $>$} (Functor finding the theory and/or the negative border and/or the positive border using the {\bf Apriori}{\rm (p.\,\pageref{class_apriori})} strategy but with a top down exploration of the search space )}{\pageref{class_apriori_reverse}}{}
\item\contentsline{section}{{\bf Binary\-DB$<$ Sets\-Type, Data\-Struct\-DB $>$} (Binary\-DB\_\-base represents a binary relation, a transactionnal data bases )}{\pageref{class_binary_d_b}}{}
\item\contentsline{section}{{\bf Boolean} ({\bf Boolean}{\rm (p.\,\pageref{class_boolean})} type )}{\pageref{class_boolean}}{}
\item\contentsline{section}{{\bf Complement$<$ Sets\-Type $>$} (Functor that complements a set )}{\pageref{class_complement}}{}
\item\contentsline{section}{{\bf Essential$<$ Data, Sets\-Type $>$} (Functor representing the predicate being frequent essential )}{\pageref{class_essential}}{}
\item\contentsline{section}{{\bf Fdep\-File} (Read a relation saved in the Fdep format )}{\pageref{class_fdep_file}}{}
\item\contentsline{section}{{\bf Fimi\-File$<$ Sets\-Type $>$} (Class used to read a transactionnal db in the FIMI format and save data in the FIMI format )}{\pageref{class_fimi_file}}{}
\item\contentsline{section}{{\bf Fimi\-File$<$ Sets\-Type $>$::save\-Container\-In\-File} (Functor used to save in the file each set )}{\pageref{class_fimi_file_1_1save_container_in_file}}{}
\item\contentsline{section}{{\bf Fimi\-File$<$ Sets\-Type $>$::save\-Elem\-In\-File} (Functor used to save in the file each element of a set )}{\pageref{class_fimi_file_1_1save_elem_in_file}}{}
\item\contentsline{section}{{\bf Fimi\-File\-C$<$ Container\-Trans $>$} (Class used to read a transactionnal db in the FIMI format and save data in the FIMI format )}{\pageref{class_fimi_file_c}}{}
\item\contentsline{section}{{\bf Fimi\-File\-C$<$ Container\-Trans $>$::save\-Container\-In\-File} (Functor used to save in the file each set )}{\pageref{class_fimi_file_c_1_1save_container_in_file}}{}
\item\contentsline{section}{{\bf Fimi\-File\-C$<$ Container\-Trans $>$::save\-Elem\-In\-File} (Functor used to save in the file each element of a set )}{\pageref{class_fimi_file_c_1_1save_elem_in_file}}{}
\item\contentsline{section}{{\bf Frequent$<$ Data, Sets\-Type $>$} (Functor representing the predicate being frequent )}{\pageref{class_frequent}}{}
\item\contentsline{section}{{\bf Frequent$<$ Data, Sets\-Type $>$::eq\-Item\-Supp} (Functor used to find an item in the list of items/support )}{\pageref{class_frequent_1_1eq_item_supp}}{}
\item\contentsline{section}{{\bf Frequent$<$ Data, Sets\-Type $>$::order} (Functor used to reorder a transaction )}{\pageref{class_frequent_1_1order}}{}
\item\contentsline{section}{{\bf Frequent$<$ Data, Sets\-Type $>$::reorder\-Trans} (Functor that reorders a transaction and insert it in the db )}{\pageref{class_frequent_1_1reorder_trans}}{}
\item\contentsline{section}{{\bf Id} (Functor that represents identity function )}{\pageref{class_id}}{}
\item\contentsline{section}{{\bf IND} (Class representing a {\bf IND}{\rm (p.\,\pageref{class_i_n_d})} )}{\pageref{class_i_n_d}}{}
\item\contentsline{section}{{\bf Init\-Frequent$<$ Sets\-Type, Binary\-DB, Predicate $>$} (Functor used to initialize the frequent items )}{\pageref{class_init_frequent}}{}
\item\contentsline{section}{{\bf Init\-IND$<$ Input\-DBFormat $>$} (Functor used to intialize the {\bf IND}{\rm (p.\,\pageref{class_i_n_d})} mining )}{\pageref{class_init_i_n_d}}{}
\item\contentsline{section}{{\bf Init\-IND\_\-DBMS$<$ DBMS $>$} (Functor used to intialize the {\bf IND}{\rm (p.\,\pageref{class_i_n_d})} mining )}{\pageref{class_init_i_n_d___d_b_m_s}}{}
\item\contentsline{section}{{\bf Init\-Key$<$ Attribute\-Type, Input\-DBFormat $>$} (Functor used to intialize the not redundant mining )}{\pageref{class_init_key}}{}
\item\contentsline{section}{{\bf Is\-Almost\-Freq} (Determine if a not frequent itemset is near the positive border in the ABS algorithm )}{\pageref{class_is_almost_freq}}{}
\item\contentsline{section}{{\bf It\-Binary\-DB$<$ Sets\-Type, Data\-Struct\-DB, Container $>$} (Iterator on a {\bf Binary\-DB}{\rm (p.\,\pageref{class_binary_d_b})} )}{\pageref{class_it_binary_d_b}}{}
\item\contentsline{section}{{\bf It\-Fimi\-File$<$ Sets\-Type $>$} (Iterator on a {\bf Fimi\-File}{\rm (p.\,\pageref{class_fimi_file})} )}{\pageref{class_it_fimi_file}}{}
\item\contentsline{section}{{\bf It\-PTree$<$ Sets\-Type, Measure $>$} (Iterator on a {\bf PTree}{\rm (p.\,\pageref{class_p_tree})} (trie data structure) )}{\pageref{class_it_p_tree}}{}
\item\contentsline{section}{{\bf It\-Tatree$<$ Sets\-Type $>$} (Iterator on a {\bf Tatree}{\rm (p.\,\pageref{class_tatree})} data structure (trie) )}{\pageref{class_it_tatree}}{}
\item\contentsline{section}{{\bf It\-Tatree\_\-base$<$ Sets\-Type $>$} (Iterator on a {\bf Tatree\_\-base}{\rm (p.\,\pageref{class_tatree__base})} (trie data structure) )}{\pageref{class_it_tatree__base}}{}
\item\contentsline{section}{{\bf Key\_\-base$<$ Data, Attribute\-Type $>$} (Functor representing the predicate being not redundant )}{\pageref{class_key__base}}{}
\item\contentsline{section}{{\bf Key\_\-base$<$ Data, Attribute\-Type $>$::Process\-Tuples$<$ Iterator $>$} (Functor used to projet all the tuples wrt attributes studied )}{\pageref{class_key__base_1_1_process_tuples}}{}
\item\contentsline{section}{{\bf Key\_\-base$<$ Data, Attribute\-Type $>$::project$<$ Container\-Tuple $>$} (Functor used to projet a tuple wrt the set of attributes studied )}{\pageref{class_key__base_1_1project}}{}
\item\contentsline{section}{{\bf Node$<$ Sets\-Type, Measure $>$} (Class representing a node of the {\bf PTree}{\rm (p.\,\pageref{class_p_tree})} )}{\pageref{class_node}}{}
\item\contentsline{section}{{\bf No\-Output} (Class used to not store/output a solution of the algorithm )}{\pageref{class_no_output}}{}
\item\contentsline{section}{{\bf Not\_\-Predicate$<$ Predicate\-Neg $>$} ({\bf Predicate}{\rm (p.\,\pageref{class_predicate})} that return the negation of a predicate passed in parameter )}{\pageref{class_not___predicate}}{}
\item\contentsline{section}{{\bf Predicate} (Mother abstract functor representing a predicate )}{\pageref{class_predicate}}{}
\item\contentsline{section}{{\bf print\-Container} (Functor used to print to screen a container )}{\pageref{classprint_container}}{}
\item\contentsline{section}{{\bf print\-Container\-Of\-Container} (Functor used to print to screen a container of container )}{\pageref{classprint_container_of_container}}{}
\item\contentsline{section}{{\bf print\-Container\-Of\-Iterator$<$ Type $>$} (Functor used to print to screen a container of iterator on elements )}{\pageref{classprint_container_of_iterator}}{}
\item\contentsline{section}{{\bf PTree$<$ Sets\-Type, T $>$} (Template class representing a trie data structure of integer )}{\pageref{class_p_tree}}{}
\item\contentsline{section}{{\bf Recode$<$ Data\-Type, Internal\-Type $>$} (Mother abstract class to recode elements of type Data\-Type to type Internal\-Type )}{\pageref{class_recode}}{}
\item\contentsline{section}{{\bf Recode\-To\-Int$<$ Data\-Type $>$} (Class {\bf Recode\-To\-Int}{\rm (p.\,\pageref{class_recode_to_int})} recode data oftype T in integers and stor the mapping )}{\pageref{class_recode_to_int}}{}
\item\contentsline{section}{{\bf Record\-Distribution$<$ Output $>$} (Class used to store the distribution of a solution find by an algorithm (and evantually save the solution in an output object) )}{\pageref{class_record_distribution}}{}
\item\contentsline{section}{{\bf Satisfied\-IND$<$ Data $>$} (Functor representing the predicate being a satisfied {\bf IND}{\rm (p.\,\pageref{class_i_n_d})} wrt to 2 relations )}{\pageref{class_satisfied_i_n_d}}{}
\item\contentsline{section}{{\bf Satisfied\-IND$<$ Data $>$::Process\-Tuples$<$ Container\-Attrib, Container\-Project $>$} (Functor used to projet all the tuples wrt attributes studied )}{\pageref{class_satisfied_i_n_d_1_1_process_tuples}}{}
\item\contentsline{section}{{\bf Satisfied\-IND$<$ Data $>$::project2$<$ Container\-Tuple $>$} (Functor used to projet a tuple wrt the set of attributes studied )}{\pageref{class_satisfied_i_n_d_1_1project2}}{}
\item\contentsline{section}{{\bf Satisfied\-IND\_\-DBMS$<$ DBMS $>$} (Functor representing the predicate being a satisfied {\bf IND}{\rm (p.\,\pageref{class_i_n_d})} wrt to 2 relations in a SGBD )}{\pageref{class_satisfied_i_n_d___d_b_m_s}}{}
\item\contentsline{section}{{\bf save\-Container} (Functor used to save the data of a container in a file )}{\pageref{classsave_container}}{}
\item\contentsline{section}{{\bf save\-Container\-Of\-Container} (Functor used to save the data of a container of container )}{\pageref{classsave_container_of_container}}{}
\item\contentsline{section}{{\bf Stop\-Ite\-Distrib} (Functor used in parameter of {\bf Apriori}{\rm (p.\,\pageref{class_apriori})} to stop the execution of the algorithm wrt distribution of elements found )}{\pageref{class_stop_ite_distrib}}{}
\item\contentsline{section}{{\bf Support} (Class used to store additional informations in each node, here the support of the corresponding items )}{\pageref{class_support}}{}
\item\contentsline{section}{{\bf Support\-Disj} (Class used to store additional informations in each node, here the support and the disjunction of the corresponding items )}{\pageref{class_support_disj}}{}
\item\contentsline{section}{{\bf Tabular\-DBFile} (Read a tabular db and save solution in a file in the FIMI format )}{\pageref{class_tabular_d_b_file}}{}
\item\contentsline{section}{{\bf Tabular\-DBFile::save\-Container\-In\-File} (Functor used to save a solution in the file )}{\pageref{class_tabular_d_b_file_1_1save_container_in_file}}{}
\item\contentsline{section}{{\bf Tabular\-DBFile::save\-Elem\-In\-File} (Functore used to save an element of a solution in the file )}{\pageref{class_tabular_d_b_file_1_1save_elem_in_file}}{}
\item\contentsline{section}{{\bf Tatree$<$ Sets\-Type $>$} (Template class representing a trie data structure (this is an \char`\"{}interface\char`\"{} of the Tatre\_\-base class) )}{\pageref{class_tatree}}{}
\item\contentsline{section}{{\bf Tatree\_\-base$<$ Sets\-Type $>$} (Template class representing a trie data structure )}{\pageref{class_tatree__base}}{}
\item\contentsline{section}{{\bf Tatree\-Node$<$ Sets\-Type $>$} (Template class representing a node of a trie data structure )}{\pageref{class_tatree_node}}{}
\item\contentsline{section}{{\bf Tatree\-Node$<$ Sets\-Type $>$::insert\-Node} (Functor used to add an element in a node )}{\pageref{class_tatree_node_1_1insert_node}}{}
\item\contentsline{section}{{\bf Test\-Subsets$<$ Sets\-Type $>$} (Functor testing all the k-1 subsets of the itemset passed in parameter wrt to a binary predicate )}{\pageref{class_test_subsets}}{}
\item\contentsline{section}{{\bf Transform\-Element$<$ Transform\-Set, Sets\-Type, Word\-To\-Set, Word $>$} (Functor used to transform elements of the langugage )}{\pageref{class_transform_element}}{}
\item\contentsline{section}{{\bf Unary\-IND} (Class representing the inclusion between two attributes )}{\pageref{class_unary_i_n_d}}{}
\end{CompactList}
